#include <project.h>
#include "stdio.h"
#include "USBUART_1_cdc.h"
#define MIN_COUNT 0
#define MAX_COUNT 0xFF


/* DMA Configuration constants for DMA_1 */
#define DMA_BYTES_PER_BURST (1u)
#define DMA_REQUEST_PER_BURST (1u)
#define DMA_SRC_BASE (ADDA_BUFFER)//(CYDEV_PERIPH_BASE)
#define DMA_DST_BASE (CYDEV_PERIPH_BASE)

uint8 ADDA_BUFFER[1];
void DMA_Config(void);

#if defined (__GNUC__)
/* Add an explicit reference to the floating point printf library */
/* to allow the usage of floating point conversion specifiers. */
/* This is not linked in by default with the newlib-nano library. */
asm (".global _printf_float");
#endif
/* The size of the buffer is equal to maximum packet size of the
* IN and OUT bulk endpoints.
*/
#define BUFFER_LEN 64u
char8 *parity[] = { "None", "Odd", "Even", "Mark", "Space" };
char8 *stop[] = { "1", "1.5", "2" };

/*capsense*/
#define ON (1)
#define OFF (0)
#define NO_FINGER (0xFF)
int main()
{
    uint16 count;
    char buffer[BUFFER_LEN];
    uint8 last = -1;
    char8 lineStr[20];
    char result[3];
    uint8 state;
    int16 voltageRawCount;
    uint8 statusButton0 = OFF;
    uint8 statusButton1 = OFF;
    uint16 sliderPosition = NO_FINGER;
    uint16 lastPosition = NO_FINGER;
    uint8 vdac_data;
    
    
    /* Enable Global Interrupts */
    CyGlobalIntEnable;
    /* Start USBFS Operation with 3V operation */
    USBUART_1_Start(0u, USBUART_1_3V_OPERATION);
    /* Start LCD */
    LCD_Start();
    /* Wait for Device to enumerate */
    while(!USBUART_1_GetConfiguration());
    /* Enumeration is done, enable OUT endpoint for receive data from Host */
    USBUART_1_CDC_Init();
    
    /*ADC and DAC*/
    ADC_Start();
    VDAC_Start();
    Opamp_Start();
    DMA_Config();
    ADC_StartConvert();
    
    LCD_Position(0u, 0u);
    LCD_PrintString("LED: ");
    
    /* Start capsense and initialize baselines and enable scan */
    CapSense_Start();
    CapSense_InitializeAllBaselines();
    CapSense_ScanEnabledWidgets();
    /* Main Loop: */
    
    for(;;)
    {
                /* If scanning is completed update the baseline count and check if sensor is active */
        if(!CapSense_IsBusy())
        {
            /* Update baseline for all the sensors */
            CapSense_UpdateEnabledBaselines();
            CapSense_ScanEnabledWidgets();
            sliderPosition =(uint8)CapSense_GetCentroidPos(CapSense_LINEARSLIDER0__LS);
            /* Finger detected on the slider */
            if (sliderPosition != NO_FINGER)
            {
                /* If finger position on the slider is changed then update the LCD */
                if(sliderPosition != lastPosition)
                {
                    lastPosition = sliderPosition;
                }
            }
        }
        if (sliderPosition != NO_FINGER)
        {
            ADDA_BUFFER[0] = (uint8)(sliderPosition / 100.0 * 255);
            vdac_data = sliderPosition;
            if (last != vdac_data)
            {
                LCD_Position(0u, strlen("LED: "));
                sprintf(result, "%3d", vdac_data);
                LCD_PrintString(result);
                sprintf(buffer, "LED Intensity: %3d\r\n", vdac_data);
                USBUART_1_PutData((uint8 *)buffer, strlen(buffer)); /* Send data back to PC */
                last = vdac_data;
            }
            continue;
        }
        /* Wait for end of conversion */
        ADC_IsEndConversion(ADC_WAIT_FOR_RESULT);
        voltageRawCount = ADC_GetResult16();
        if (voltageRawCount < MIN_COUNT)
        {
            voltageRawCount = MIN_COUNT;
        }
        /* Used to remove the count beyond 8 bit value, see resolution section
        * in DelSig ADC datasheet */
        else if(voltageRawCount > MAX_COUNT)
        {
            voltageRawCount = MAX_COUNT;
        }
        ADDA_BUFFER[0] = voltageRawCount & 0xFF;
        /* If converted ADC value has been transferred to VDAC, print results */
        if(Status_Reg_1_Read())
        {
            
            /* Print the ADC output value on LCD */
            vdac_data = (int)(ADDA_BUFFER[0] / 255.0 * 100);
            LCD_Position(0u, strlen("LED: "));
            sprintf(result, "%3d", vdac_data);
            LCD_PrintString(result);

            if (last != vdac_data)
            {
                sprintf(buffer, "LED Intensity: %3d\r\n", vdac_data);
                USBUART_1_PutData((uint8 *)buffer, strlen(buffer)); /* Send data back to PC */
                while(USBUART_1_CDCIsReady() == 0u);
                last = vdac_data;
            }

        }

    }
}

/*******************************************************************************
* Function Name:  DMA_Config
********************************************************************************
*
* Summary:
*    Code generated by the DMA Wizard.
*
*    DMA_Config() performs following functions:
*  1: Initializes the DMA channel
*  2: Allocates Transfer Descriptors
*  3: Configures the TD.
*  4: Sets source and destination address for this TD.
*  5: Initializes the TD.
*  6: Enables the DMA channel.
*
* Parameters:
*  None.
*
* Return:
*  None.
*
*******************************************************************************/
void DMA_Config()
{
    /* Variable declarations for DMA */
    uint8 DMA_Chan;
    uint8 DMA_TD[1] = {0};

    /* Iniitialize DMA channel */
    DMA_Chan = DMA_DmaInitialize(DMA_BYTES_PER_BURST, DMA_REQUEST_PER_BURST,
                                     HI16(DMA_SRC_BASE), HI16(DMA_DST_BASE));

    /* Allocate TD */
    DMA_TD[0] = CyDmaTdAllocate();

    /* TD configuration setting */
    CyDmaTdSetConfiguration(DMA_TD[0], 1u, DMA_INVALID_TD, DMA__TD_TERMOUT_EN);

    /* Set Source and Destination address */
    CyDmaTdSetAddress(DMA_TD[0], LO16((uint32)ADDA_BUFFER),//ADC_DEC_SAMP_PTR),
                      LO16((uint32)VDAC_Data_PTR));

    /* TD initialization */
    CyDmaChSetInitialTd(DMA_Chan, DMA_TD[0]);

    /* Enable the DMA channel */
    CyDmaChEnable(DMA_Chan, 1u);
}
